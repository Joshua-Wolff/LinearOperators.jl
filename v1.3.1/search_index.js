var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [LinearOperators]","category":"page"},{"location":"reference/#Base.Matrix-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T","page":"Reference","title":"Base.Matrix","text":"A = Matrix(op)\n\nMaterialize an operator as a dense array using op.ncol products.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.LBFGSData","page":"Reference","title":"LinearOperators.LBFGSData","text":"A data type to hold information relative to LBFGS operators.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.LBFGSOperator","page":"Reference","title":"LinearOperators.LBFGSOperator","text":"A type for limited-memory BFGS approximations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.LBFGSOperator-Tuple{DataType, Int64}","page":"Reference","title":"LinearOperators.LBFGSOperator","text":"LBFGSOperator(T, n; [mem=5, scaling=true])\nLBFGSOperator(n; [mem=5, scaling=true])\n\nConstruct a limited-memory BFGS approximation in forward form. If the type T is omitted, then Float64 is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.LSR1Data","page":"Reference","title":"LinearOperators.LSR1Data","text":"A data type to hold information relative to LSR1 operators.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.LSR1Operator","page":"Reference","title":"LinearOperators.LSR1Operator","text":"A type for limited-memory SR1 approximations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.LSR1Operator-Tuple{DataType, Int64}","page":"Reference","title":"LinearOperators.LSR1Operator","text":"LSR1Operator(T, n; [mem=5, scaling=false)\nLSR1Operator(n; [mem=5, scaling=false)\n\nConstruct a limited-memory SR1 approximation in forward form. If the type T is omitted, then Float64 is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.LinearOperator","page":"Reference","title":"LinearOperators.LinearOperator","text":"Base type to represent a linear operator. The usual arithmetic operations may be applied to operators to combine or otherwise alter them. They can be combined with other operators, with matrices and with scalars. Operators may be transposed and conjugate-transposed using the usual Julia syntax.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.LinearOperator-2","page":"Reference","title":"LinearOperators.LinearOperator","text":"LinearOperator(nrow, ncol, symmetric, hermitian, prod,\n                [tprod=nothing,\n                ctprod=nothing])\n\nConstruct a linear operator from functions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.LinearOperator-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.LinearOperator","text":"LinearOperator(M; symmetric=false, hermitian=false)\n\nConstruct a linear operator from a dense or sparse matrix. Use the optional keyword arguments to indicate whether the operator is symmetric and/or hermitian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Hermitian{T, S} where S<:(AbstractMatrix{var\"#s832\"} where var\"#s832\"<:T)}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.LinearOperator","text":"LinearOperator(M)\n\nConstructs a linear operator from a Hermitian matrix. If its elements are real, it is also symmetric.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractVector{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.LinearOperator","text":"LinearOperator(M)\n\nConstructs a linear operator from a symmetric tridiagonal matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Symmetric{T, S} where S<:(AbstractMatrix{var\"#s832\"} where var\"#s832\"<:T)}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.LinearOperator","text":"LinearOperator(M)\n\nConstructs a linear operator from a symmetric matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.LinearOperator-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64, Bool, Bool, Any}, Tuple{Type{T}, Int64, Int64, Bool, Bool, Any, Any}, Tuple{Type{T}, Int64, Int64, Bool, Bool, Any, Any, Any}} where T","page":"Reference","title":"LinearOperators.LinearOperator","text":"LinearOperator(type, nrow, ncol, symmetric, hermitian, prod,\n                [tprod=nothing,\n                ctprod=nothing])\n\nConstruct a linear operator from functions where the type is specified as the first argument. Notice that the linear operator does not enforce the type, so using a wrong type can result in errors. For instance,\n\nA = [im 1.0; 0.0 1.0] # Complex matrix\nop = LinearOperator(Float64, 2, 2, false, false, v->A*v, u->transpose(A)*u, w->A'*w)\nMatrix(op) # InexactError\n\nThe error is caused because Matrix(op) tries to create a Float64 matrix with the contents of the complex matrix A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.PreallocatedLinearOperator","page":"Reference","title":"LinearOperators.PreallocatedLinearOperator","text":"Type to represent a linear operator with preallocation. Implicit modifications may happen if used without care:\n\nop = PreallocatedLinearOperator(rand(5, 5))\nv  = rand(5)\nx = op * v        # Uses internal storage and passes pointer to x\ny = op * ones(5)  # Overwrites the same memory as x.\ny === x           # true. op * v is lost\n\nx = op * v        # Uses internal storage and passes pointer to x\ny = op * x        # Silently overwrite x to zeros! Equivalent to mul!(x, A, x).\ny == zeros(5)     # true. op * v and op * x are lost\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.PreallocatedLinearOperator-Union{Tuple{LinearAlgebra.Hermitian{T, S} where S<:(AbstractMatrix{var\"#s832\"} where var\"#s832\"<:T)}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.PreallocatedLinearOperator","text":"PreallocatedLinearOperator(M)\n\nConstructs a linear operator from a Hermitian matrix. If its elements are real, it is also symmetric.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.PreallocatedLinearOperator-Union{Tuple{LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractVector{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.PreallocatedLinearOperator","text":"PreallocatedLinearOperator(M)\n\nConstructs a linear operator from a symmetric tridiagonal matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.PreallocatedLinearOperator-Union{Tuple{LinearAlgebra.Symmetric{T, S} where S<:(AbstractMatrix{var\"#s832\"} where var\"#s832\"<:T)}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.PreallocatedLinearOperator","text":"PreallocatedLinearOperator(M)\n\nConstructs a linear operator from a symmetric matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.PreallocatedLinearOperator-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}}} where T","page":"Reference","title":"LinearOperators.PreallocatedLinearOperator","text":"PreallocatedLinearOperator(Mv, Mtu, Maw, M; symmetric=false, hermitian=false)\n\nConstruct a linear operator from a dense or sparse matrix, using Mv as storage space for M * v and Mtu as storage space for transpose(M) * u and Maw to store adjoint(M) * w. Use the optional keyword arguments to indicate whether the operator is symmetric and/or hermitian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.PreallocatedLinearOperator-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractVector{T}, LinearAlgebra.Symmetric{T, S} where S<:(AbstractMatrix{var\"#s832\"} where var\"#s832\"<:T)}}} where T<:Real","page":"Reference","title":"LinearOperators.PreallocatedLinearOperator","text":"PreallocatedLinearOperator(Mv, M :: Symmetric{<:Real})\n\nConstruct a linear operator from a symmetric real square matrix M with preallocation using Mv as storage space.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.TimedLinearOperator-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.TimedLinearOperator","text":"TimedLinearOperator(op)\n\nCreates a linear operator instrumented with timers from TimerOutputs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opEye","page":"Reference","title":"LinearOperators.opEye","text":"opEye()\n\nIdentity operator.\n\nopI = opEye()\nv = rand(5)\n@assert opI * v === v\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearOperators.opEye-Tuple{DataType, Int64, Int64}","page":"Reference","title":"LinearOperators.opEye","text":"opEye(T, nrow, ncol)\nopEye(nrow, ncol)\n\nRectangular identity operator of size nrowxncol and of data type T (defaults to Float64).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opEye-Tuple{DataType, Int64}","page":"Reference","title":"LinearOperators.opEye","text":"opEye(T, n)\nopEye(n)\n\nIdentity operator of order n and of data type T (defaults to Float64).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.kron-Tuple{AbstractLinearOperator, AbstractLinearOperator}","page":"Reference","title":"Base.kron","text":"kron(A, B)\n\nKronecker tensor product of A and B in linear operator form, if either or both are linear operators. If both A and B are matrices, then Base.kron is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.push!","page":"Reference","title":"Base.push!","text":"push!(op, s, y)\npush!(op, s, y, α, g)\n\nPush a new {s,y} pair into a L-BFGS operator. The second calling sequence is used in inverse LBFGS updating in conjunction with damping, where α is the most recent steplength and g the gradient used when solving d=-Hg. In forward updating with damping, it is not necessary to supply α and g.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.push!-Tuple{LSR1Operator, AbstractVector{T} where T, AbstractVector{T} where T}","page":"Reference","title":"Base.push!","text":"push!(op, s, y)\n\nPush a new {s,y} pair into a L-SR1 operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, AbstractLinearOperator}","page":"Reference","title":"Base.show","text":"show(io, op)\n\nDisplay basic information about a linear operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, LinearOperators.AbstractPreallocatedLinearOperator}","page":"Reference","title":"Base.show","text":"show(io, op)\n\nDisplay basic information about a linear operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.size-Tuple{AbstractLinearOperator, Int64}","page":"Reference","title":"Base.size","text":"m = size(op, d)\n\nReturn the size of a linear operator along dimension d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.size-Tuple{AbstractLinearOperator}","page":"Reference","title":"Base.size","text":"m, n = size(op)\n\nReturn the size of a linear operator as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.diag-Union{Tuple{LBFGSOperator{T}}, Tuple{T}} where T","page":"Reference","title":"LinearAlgebra.diag","text":"diag(op)\ndiag!(op, d)\n\nExtract the diagonal of a L-BFGS operator in forward mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.diag-Union{Tuple{LSR1Operator{T}}, Tuple{T}} where T","page":"Reference","title":"LinearAlgebra.diag","text":"diag(op)\ndiag!(op, d)\n\nExtract the diagonal of a L-SR1 operator in forward mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.BlockDiagonalOperator-Tuple","page":"Reference","title":"LinearOperators.BlockDiagonalOperator","text":"BlockDiagonalOperator(M1, M2, ..., Mn)\n\nCreates a block-diagonal linear operator:\n\n[ M1           ]\n[    M2        ]\n[       ...    ]\n[           Mn ]\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.InverseLBFGSOperator-Tuple{DataType, Int64}","page":"Reference","title":"LinearOperators.InverseLBFGSOperator","text":"InverseLBFGSOperator(T, n, [mem=5; scaling=true])\nInverseLBFGSOperator(n, [mem=5; scaling=true])\n\nConstruct a limited-memory BFGS approximation in inverse form. If the type T is omitted, then Float64 is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.check_ctranspose-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T<:Union{AbstractFloat, Complex}","page":"Reference","title":"LinearOperators.check_ctranspose","text":"check_ctranspose(op)\n\nCheap check that the operator and its conjugate transposed are related.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.check_hermitian-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T<:Union{AbstractFloat, Complex}","page":"Reference","title":"LinearOperators.check_hermitian","text":"check_hermitian(op)\n\nCheap check that the operator is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.check_positive_definite-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T<:Union{AbstractFloat, Complex}","page":"Reference","title":"LinearOperators.check_positive_definite","text":"check_positive_definite(op; semi=false)\n\nCheap check that the operator is positive (semi-)definite.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.hermitian-Tuple{AbstractLinearOperator}","page":"Reference","title":"LinearOperators.hermitian","text":"hermitian(op)\nishermitian(op)\n\nDetermine whether the operator is Hermitian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opCholesky-Tuple{AbstractMatrix{T} where T}","page":"Reference","title":"LinearOperators.opCholesky","text":"opCholesky(M, [check=false])\n\nInverse of a Hermitian and positive definite matrix as a linear operator using its Cholesky factorization. The factorization is computed only once. The optional check argument will perform cheap hermicity and definiteness checks.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opDiagonal-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.opDiagonal","text":"opDiagonal(d)\n\nDiagonal operator with the vector d on its main diagonal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opDiagonal-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T","page":"Reference","title":"LinearOperators.opDiagonal","text":"opDiagonal(nrow, ncol, d)\n\nRectangular diagonal operator of size nrow-by-ncol with the vector d on its main diagonal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opExtension-Tuple{AbstractVector{Int64}, Int64}","page":"Reference","title":"LinearOperators.opExtension","text":"Z = opExtension(I, ncol)\nZ = opExtension(:, ncol)\n\nCreates a LinearOperator extending a vector of size length(I) to size ncol, where the position of the elements on the new vector are given by the indices I. The operation w = Z * v is equivalent to w = zeros(ncol); w[I] = v.\n\nZ = opExtension(k, ncol)\n\nAlias for opExtension([k], ncol).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opHermitian-Tuple{AbstractMatrix{T} where T}","page":"Reference","title":"LinearOperators.opHermitian","text":"opHermitian(A)\n\nA symmetric/hermitian operator based on a matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opHermitian-Union{Tuple{T}, Tuple{S}, Tuple{AbstractVector{S}, AbstractMatrix{T}}} where {S, T}","page":"Reference","title":"LinearOperators.opHermitian","text":"opHermitian(d, A)\n\nA symmetric/hermitian operator based on the diagonal d and lower triangle of A.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opHouseholder-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.opHouseholder","text":"opHouseholder(h)\n\nApply a Householder transformation defined by the vector h. The result is x -> (I - 2 h h') x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opInverse-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.opInverse","text":"opInverse(M; symmetric=false, hermitian=false)\n\nInverse of a matrix as a linear operator using \\. Useful for triangular matrices. Note that each application of this operator applies \\.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opLDL-Tuple{AbstractMatrix{T} where T}","page":"Reference","title":"LinearOperators.opLDL","text":"opLDL(M, [check=false])\n\nInverse of a symmetric matrix as a linear operator using its LDL' factorization if it exists. The factorization is computed only once. The optional check argument will perform a cheap hermicity check.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opOnes-Tuple{DataType, Int64, Int64}","page":"Reference","title":"LinearOperators.opOnes","text":"opOnes(T, nrow, ncol)\nopOnes(nrow, ncol)\n\nOperator of all ones of size nrow-by-ncol and of data type T (defaults to Float64).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opRestriction-Tuple{AbstractVector{Int64}, Int64}","page":"Reference","title":"LinearOperators.opRestriction","text":"Z = opRestriction(I, ncol)\nZ = opRestriction(:, ncol)\n\nCreates a LinearOperator restricting a ncol-sized vector to indices I. The operation Z * v is equivalent to v[I]. I can be :.\n\nZ = opRestriction(k, ncol)\n\nAlias for opRestriction([k], ncol).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.opZeros-Tuple{DataType, Int64, Int64}","page":"Reference","title":"LinearOperators.opZeros","text":"opZeros(T, nrow, ncol)\nopZeros(nrow, ncol)\n\nZero operator of size nrow-by-ncol and of data type T (defaults to Float64).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.reset!-Tuple{AbstractLinearOperator}","page":"Reference","title":"LinearOperators.reset!","text":"reset!(op)\n\nReset the product counters of a linear operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.reset!-Tuple{LBFGSOperator}","page":"Reference","title":"LinearOperators.reset!","text":"reset!(op)\n\nResets the LBFGS data of the given operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.reset!-Tuple{LSR1Operator}","page":"Reference","title":"LinearOperators.reset!","text":"reset!(op)\n\nResets the LSR1 data of the given operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.reset!-Union{Tuple{LinearOperators.LSR1Data{T}}, Tuple{T}} where T","page":"Reference","title":"LinearOperators.reset!","text":"reset!(data)\n\nReset the given LSR1 data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.reset!-Union{Tuple{T}, Tuple{LinearOperators.LBFGSData{T}, Bool}} where T","page":"Reference","title":"LinearOperators.reset!","text":"reset!(data)\n\nResets the given LBFGS data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.shape-Tuple{AbstractLinearOperator}","page":"Reference","title":"LinearOperators.shape","text":"m, n = shape(op)\n\nAn alias for size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearOperators.symmetric-Tuple{AbstractLinearOperator}","page":"Reference","title":"LinearOperators.symmetric","text":"symmetric(op)\nissymmetric(op)\n\nDetermine whether the operator is symmetric.\n\n\n\n\n\n","category":"method"},{"location":"#A-Julia-Linear-Operator-Package","page":"Home","title":"A Julia Linear Operator Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Operators behave like matrices (with exceptions) but are defined by their effect when applied to a vector. They can be transposed, conjugated, or combined with other operators cheaply. The costly operation is deferred until multiplied with a vector.","category":"page"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia 0.6 and up.","category":"page"},{"location":"#How-to-Install","page":"Home","title":"How to Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"LinearOperators\")","category":"page"},{"location":"#Operators-Available","page":"Home","title":"Operators Available","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Operator Description\nLinearOperator Base class. Useful to define operators from functions\nPreallocatedLinearOperator Define operators with preallocation for efficient use of memory\nTimedLinearOperator Linear operator instrumented with timers from TimerOutputs\nBlockDiagonalOperator Block-diagonal linear operator\nopEye Identity operator\nopOnes All ones operator\nopZeros All zeros operator\nopDiagonal Square (equivalent to diagm()) or rectangular diagonal operator\nopInverse Equivalent to \\\nopCholesky More efficient than opInverse for symmetric positive definite matrices\nopLDL Similar to opCholesky, for general sparse symmetric matrices\nopHouseholder Apply a Householder transformation I-2hh'\nopHermitian Represent a symmetric/hermitian operator based on the diagonal and strict lower triangle\nopRestriction Represent a selection of \"rows\" when composed on the left with an existing operator\nopExtension Represent a selection of \"columns\" when composed on the right with an existing operator\nLBFGSOperator Limited-memory BFGS approximation in operator form (damped or not)\nInverseLBFGSOperator Inverse of a limited-memory BFGS approximation in operator form (damped or not)\nLSR1Operator Limited-memory SR1 approximation in operator form\nkron Kronecker tensor product in linear operator form","category":"page"},{"location":"#Utility-Functions","page":"Home","title":"Utility Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Function Description\ncheck_ctranspose Cheap check that A' is correctly implemented\ncheck_hermitian Cheap check that A = A'\ncheck_positive_definite Cheap check that an operator is positive (semi-)definite\ndiag Extract the diagonal of an operator\nMatrix Convert an abstract operator to a dense array\nhermitian Determine whether the operator is Hermitian\npush! For L-BFGS or L-SR1 operators, push a new pair {s,y}\nreset! For L-BFGS or L-SR1 operators, reset the data\nshape Return the size of a linear operator\nshow Display basic information about an operator\nsize Return the size of a linear operator\nsymmetric Determine whether the operator is symmetric","category":"page"},{"location":"#Other-Operations-on-Operators","page":"Home","title":"Other Operations on Operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Operators can be transposed (A.'), conjugated (conj(A)) and conjugate-transposed (A'). Operators can be sliced (A[:,3], A[2:4,1:5], A[1,1]), but unlike matrices, slices always return operators (see differences).","category":"page"},{"location":"#differences","page":"Home","title":"Differences","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unlike matrices, an operator never reduces to a vector or a number.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearOperators #hide\nA = rand(5,5)\nopA = LinearOperator(A)\nA[:,1] * 3 # Vector","category":"page"},{"location":"","page":"Home","title":"Home","text":"opA[:,1] * 3 # LinearOperator","category":"page"},{"location":"","page":"Home","title":"Home","text":"# A[:,1] * [3] # ERROR","category":"page"},{"location":"","page":"Home","title":"Home","text":"opA[:,1] * [3] # Vector","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is also true for A[i,:], which returns vectors on Julia 0.6, and for the scalar A[i,j]. Similarly, opA[1,1] is an operator of size (1,1):\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"(opA[1,1] * [3])[1] - A[1,1] * 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the same spirit, the operator Matrix always returns a matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Matrix(opA[:,1])","category":"page"},{"location":"#Other-Operators","page":"Home","title":"Other Operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LLDL features a limited-memory LDLᵀ factorization operator that may be used as preconditioner in iterative methods\nMUMPS.jl features a full distributed-memory factorization operator that may be used to represent the preconditioner in, e.g., constraint-preconditioned Krylov methods.","category":"page"},{"location":"#Testing","page":"Home","title":"Testing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.test(\"LinearOperators\")","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This section of the documentation describes a few uses of LinearOperators.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]","category":"page"},{"location":"tutorial/#Using-matrices","page":"Tutorial","title":"Using matrices","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Operators may be defined from matrices and combined using the usual operations, but the result is deferred until the operator is applied.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearOperators, SparseArrays\nA1 = rand(5,7)\nA2 = sprand(7,3,.3)\nop1 = LinearOperator(A1)\nop2 = LinearOperator(A2)\nop = op1 * op2  # Does not form A1 * A2\nx = rand(3)\ny = op * x","category":"page"},{"location":"tutorial/#Inverse","page":"Tutorial","title":"Inverse","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Operators may be defined to represent (approximate) inverses.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearAlgebra\nA = rand(5,5)\nA = A' * A\nop = opCholesky(A)  # Use, e.g., as a preconditioner\nv = rand(5)\nnorm(A \\ v - op * v) / norm(v)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example, the Cholesky factor is computed only once and can be used many times transparently.","category":"page"},{"location":"tutorial/#Using-functions","page":"Tutorial","title":"Using functions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Operators may be defined from functions. In the example below, the transposed isn't defined, but it may be inferred from the conjugate transposed. Missing operations are represented as nothing.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FFTW\ndft = LinearOperator(10, 10, false, false,\n                     v -> fft(v),\n                     nothing,       # will be inferred\n                     w -> ifft(w))\nx = rand(10)\ny = dft * x\nnorm(dft' * y - x)  # DFT is an orthogonal operator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"transpose(dft) * y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default a linear operator defined by functions and that is neither symmetric nor hermitian will have element type Complex128. This behavior may be overridden by specifying the type explicitly, e.g.,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"op = LinearOperator(Float64, 10, 10, false, false,\n                    v -> [v[1] + v[2]; v[2]],\n                    nothing,\n                    w -> [w[1]; w[1] + w[2]])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Make sure that the type passed to LinearOperator is correct, otherwise errors may occur.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearOperators, FFTW # hide\ndft = LinearOperator(Float64, 10, 10, false, false,\n                     v -> fft(v),\n                     nothing,\n                     w -> ifft(w))\nv = rand(10)\nprintln(\"eltype(dft)         = $(eltype(dft))\")\nprintln(\"eltype(v)           = $(eltype(v))\")\nprintln(\"eltype(dft.prod(v)) = $(eltype(dft.prod(v)))\")\n# dft * v     # ERROR: expected Vector{Float64}\n# Matrix(dft) # ERROR: tried to create a Matrix of Float64","category":"page"},{"location":"tutorial/#Limited-memory-BFGS-and-SR1","page":"Tutorial","title":"Limited memory BFGS and SR1","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Two other useful operators are the Limited-Memory BFGS in forward and inverse form.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B = LBFGSOperator(20)\nH = InverseLBFGSOperator(20)\nr = 0.0\nfor i = 1:100\n  global r\n  s = rand(20)\n  y = rand(20)\n  push!(B, s, y)\n  push!(H, s, y)\n  r += norm(B * H * s - s)\nend\nr","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There is also a LSR1 operator that behaves similarly to these two.","category":"page"},{"location":"tutorial/#Restriction,-extension-and-slices","page":"Tutorial","title":"Restriction, extension and slices","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The restriction operator restricts a vector to a set of indices.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"v = collect(1:5)\nR = opRestriction([2;5], 5)\nR * v","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that it corresponds to a matrix with rows of the identity given by the indices.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Matrix(R)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The extension operator is the transpose of the restriction. It extends a vector with zeros.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"v = collect(1:2)\nE = opExtension([2;5], 5)\nE * v","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With these operators, we define the slices of an operator op.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A = rand(5,5)\nopA = LinearOperator(A)\nI = [1;3;5]\nJ = 2:4\nA[I,J] * ones(3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"opRestriction(I, 5) * opA * opExtension(J, 5) * ones(3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A main difference with matrices, is that slices do not return vectors nor numbers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"opA[1,:] * ones(5)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"opA[:,1] * ones(1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"opA[1,1] * ones(1)","category":"page"},{"location":"tutorial/#Preallocated-Operators","page":"Tutorial","title":"Preallocated Operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Operators created from matrices are very practical, however, it is often useful to reuse the memory used by the operator. For that use, we can use PreallocatedLinearOperator(A) to create an operator that reuses the memory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearOperators # hide\nm, n = 50, 30\nA = rand(m, n) + im * rand(m, n)\nop1 = PreallocatedLinearOperator(A)\nop2 = LinearOperator(A)\nv = rand(n)\nal = @allocated op1 * v\nprintln(\"Allocation of PreallocatedLinearOperator product = $al\")\nv = rand(n)\nal = @allocated op2 * v\nprintln(\"Allocation of LinearOperator product = $al\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice the memory overwrite:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Av = op1 * v\nw = rand(n)\nAw = op1 * w\nAw === Av","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which doesn't happen on LinearOperator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Av = op2 * v\nw = rand(n)\nAw = op2 * w\nAw === Av","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also provide the memory to be used.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Mv  = Array{ComplexF64}(undef, m)\nMtu = Array{ComplexF64}(undef, n)\nMaw = Array{ComplexF64}(undef, n)\nop  = PreallocatedLinearOperator(Mv, Mtu, Maw, A)\nv, u, w = rand(n), rand(m), rand(m)\n(Mv === op * v, Mtu === transpose(op) * u, Maw === adjoint(op) * w)","category":"page"}]
}
